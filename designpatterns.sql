/*
Navicat MySQL Data Transfer

Source Server         : mysql
Source Server Version : 50717
Source Host           : localhost:3306
Source Database       : student2

Target Server Type    : MYSQL
Target Server Version : 50717
File Encoding         : 65001

Date: 2017-06-30 18:21:03
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for designpatterns
-- ----------------------------
DROP TABLE IF EXISTS `designpatterns`;
CREATE TABLE `designpatterns` (
  `pid` int(10) NOT NULL,
  `pname` varchar(255) DEFAULT NULL,
  `define` varchar(2000) DEFAULT NULL,
  `uml` varchar(2000) DEFAULT NULL,
  `advantage` varchar(2000) DEFAULT NULL,
  `disadvantage` varchar(2000) DEFAULT NULL,
  `apply` varchar(2000) DEFAULT NULL,
  `genuis` varchar(2000) DEFAULT NULL,
  `examcode` text,
  PRIMARY KEY (`pid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of designpatterns
-- ----------------------------
INSERT INTO `designpatterns` VALUES ('1', '简单工厂模式', '简单工厂模式（Simple Factory Pattern）属于类的创新型模式，又叫静态工厂方法模式（Static FactoryMethod Pattern）,是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。', 'images/Factory.png', '<p>①帮助封装。 简单工厂虽然很简单，但是非常友好的帮助我们实现了组件的封装，然后让组件外部能真正面向接口编程。\r\n					</p>\r\n					<p>②解耦。通过简单工厂，实现了客户端和具体实现类的解耦。如同上面的例子，客户端根本就不知道具体是由谁来实现，也不知道具体是如何实现的，客户端只是通过工厂获取它需要的接口对象。\r\n					</p>', '<p>①可能增加客户端的复杂度。 如果通过客户端的参数来选择具体的实现类，那么就必须让客户端能理解各个参数所代表的具体功能和含义，这会增加客户端使用的难度，也部分暴露了内部实现，这种情况可以选用可配置的方式来实现。\r\n					</p>\r\n					<p>②不方便扩展子工厂。 私有化简单工厂的构造方法，使用静态方法来创建接口，也就不能通过写简单工厂类的子类来改变创建接口的方法的行为了。不过，通常情况下是不需要为简单工厂创建子类的。\r\n					</p>', '<p>①如果想要完全封装隔离具体实现，让外部只能通过接口来操作封装体，那么可以选用简单工厂，让客户端通过工厂来获取相应的接口，而无需关心具体实现。</p>\r\n					<p>②如果想要把对外创建对象的职责集中管理和控制，可以选用简单工厂，一个简单工厂可以创建很多的、不相关的对象，可以把对外创建对象的职责集中到一个简单工厂来，从而实现集中管理和控制。</p>', '<p>选择实现</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Factory\r\n{\r\n    public class Operation\r\n    {\r\n        private double numberA = 0;\r\n        private double numberB = 0;\r\n        public double NumberA\r\n        {\r\n            get { return numberA; }\r\n            set { numberA = value; }\r\n        }\r\n        public double NumberB\r\n        {\r\n            get { return numberB; }\r\n            set { numberB = value; }\r\n        }\r\n        public virtual double GetResult()\r\n        {\r\n            double result = 0;\r\n            return result;\r\n        }\r\n    }\r\n    class OperationAdd:Operation\r\n    {\r\n        public override double GetResult()\r\n        {\r\n            double result = 0;\r\n            result = NumberA + NumberB;\r\n            return result;\r\n        }\r\n    }\r\n    class OperationSub:Operation\r\n    {\r\n        public override double GetResult()\r\n        {\r\n            double result = 0;\r\n            result = NumberA - NumberB;\r\n            return result;\r\n        }\r\n\r\n    }\r\n    class OperationMul : Operation\r\n    {\r\n        public override double GetResult()\r\n        {\r\n            double result = 0;\r\n            result = NumberA * NumberB;\r\n            return result;\r\n        }\r\n\r\n    }\r\n    class OperationDiv : Operation\r\n    {\r\n        public override double GetResult()\r\n        {\r\n            double result = 0;\r\n            if (NumberB == 0) throw new Exception(\"除数不能为0！\");\r\n            result = NumberA /NumberB;\r\n            return result;\r\n        }\r\n\r\n    }\r\n    public class OperationFactory\r\n    {\r\n        public static Operation createOperate(string operate)\r\n        {\r\n            Operation oper = null;\r\n            switch(operate)\r\n            {\r\n                case \"+\":\r\n                    oper = new OperationAdd();\r\n                    break;\r\n                case \"-\":\r\n                    oper = new OperationSub();\r\n                    break;\r\n                case \"*\":\r\n                    oper = new OperationMul();\r\n                    break;\r\n                case \"/\":\r\n                    oper = new OperationDiv();\r\n                    break;\r\n            }\r\n            return oper;\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Operation oper;\r\n            oper = OperationFactory.createOperate(\"+\");\r\n            oper.NumberA = 1;\r\n            oper.NumberB = 2;\r\n            double result = oper.GetResult();\r\n            Console.WriteLine(\"1+2=\"+result);\r\n            Console.Read();\r\n        }\r\n    }\r\n}					\r\n					</pre>\r\n					<P>输出结果：1+2=3</P>');
INSERT INTO `designpatterns` VALUES ('2', '抽象工厂模式', '抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。', 'images/abstract.gif', '<p>①分离接口和实现</p>\r\n					<p>②使得切换产品簇变得容易</p>', '<p>①不太容易扩展新的产品</p>\r\n					<p>②容易造成类层次复杂</p>', '<p>①如果希望一个系统独立于它的产品的创建，组合和表示的时候，换句话说，希望一个系统只是知道产品的接口，而不关心实现的时候。</p>\r\n					<p>②如果一个系统要由多个产品系列中的一个来配置的时候，换句话说，就是可以动态的切换产品簇的时候。</p>\r\n					<p>③如果要强调一系列相关产品的接口，以便联合使用它们的时候。</p>', '<p>选择产品簇的实现。</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\nusing System.Reflection;\r\nusing System.Configuration;\r\n\r\nnamespace AbstractFactory\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            User user = new User();\r\n            Department dept = new Department();\r\n\r\n            IUser iu = DataAccess.CreateUser();\r\n\r\n            iu.Insert(user);\r\n            iu.GetUser(1);\r\n\r\n            IDepartment id = DataAccess.CreateDepartment();\r\n            id.Insert(dept);\r\n            id.GetDepartment(1);\r\n\r\n            Console.Read();\r\n        }\r\n    }\r\n\r\n    class User\r\n    {\r\n        private int _id;\r\n        public int ID\r\n        {\r\n            get { return _id; }\r\n            set { _id = value; }\r\n        }\r\n\r\n        private string _name;\r\n        public string Name\r\n        {\r\n            get { return _name; }\r\n            set { _name = value; }\r\n        }\r\n    }\r\n\r\n    class Department\r\n    {\r\n        private int _id;\r\n        public int ID\r\n        {\r\n            get { return _id; }\r\n            set { _id = value; }\r\n        }\r\n\r\n        private string _deptName;\r\n        public string DeptName\r\n        {\r\n            get { return _deptName; }\r\n            set { _deptName = value; }\r\n        }\r\n    }\r\n\r\n    interface IUser\r\n    {\r\n        void Insert(User user);\r\n\r\n        User GetUser(int id);\r\n    }\r\n\r\n    class SqlserverUser : IUser\r\n    {\r\n        public void Insert(User user)\r\n        {\r\n            Console.WriteLine(\"在Sqlserver中给User表增加一条记录\");\r\n        }\r\n\r\n        public User GetUser(int id)\r\n        {\r\n            Console.WriteLine(\"在Sqlserver中根据ID得到User表一条记录\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    class AccessUser : IUser\r\n    {\r\n        public void Insert(User user)\r\n        {\r\n            Console.WriteLine(\"在Access中给User表增加一条记录\");\r\n        }\r\n\r\n        public User GetUser(int id)\r\n        {\r\n            Console.WriteLine(\"在Access中根据ID得到User表一条记录\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    interface IDepartment\r\n    {\r\n        void Insert(Department department);\r\n\r\n        Department GetDepartment(int id);\r\n    }\r\n\r\n    class SqlserverDepartment : IDepartment\r\n    {\r\n        public void Insert(Department department)\r\n        {\r\n            Console.WriteLine(\"在Sqlserver中给Department表增加一条记录\");\r\n        }\r\n\r\n        public Department GetDepartment(int id)\r\n        {\r\n            Console.WriteLine(\"在Sqlserver中根据ID得到Department表一条记录\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    class AccessDepartment : IDepartment\r\n    {\r\n        public void Insert(Department department)\r\n        {\r\n            Console.WriteLine(\"在Access中给Department表增加一条记录\");\r\n        }\r\n\r\n        public Department GetDepartment(int id)\r\n        {\r\n            Console.WriteLine(\"在Access中根据ID得到Department表一条记录\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    class DataAccess\r\n    {\r\n        private static readonly string db=\"Sqlserver\";\r\n        public static IUser CreateUser()\r\n        {\r\n            IUser result = null;\r\n            switch(db)\r\n            {\r\n                case \"Sqlserver\":\r\n                    result = new SqlserverUser();\r\n                    break;\r\n                case \"Access\":\r\n                    result = new AccessUser();\r\n                    break;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        public static IDepartment CreateDepartment()\r\n        {\r\n            IDepartment result = null;\r\n            switch(db)\r\n            {\r\n                case \"Sqlserver\":\r\n                    result = new SqlserverDepartment();\r\n                    break;\r\n                case \"Access\":\r\n                    result = new AccessDepartment();\r\n                    break;\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n}\r\n					</pre>\r\n					<p>输出结果：</p>\r\n					<img src=\"images/abf1.png\">');
INSERT INTO `designpatterns` VALUES ('3', '单例模式', '单例模式（Singleton Pattern）,保证一个类仅有一个实例，并提供一个访问它的全局访问点。', 'images/singleton.gif', '<p>①内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</p>\r\n					<p>②避免对资源的多重占用（比如写文件操作）。</p>', '<p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>', '<p>①要求生产唯一序列号。</p>\r\n					<p>②WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</p>\r\n					<p>③创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>', '<p>控制实例数组</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Singleton\r\n{\r\n    class Singleton\r\n    {\r\n        private static Singleton instance;\r\n        private Singleton() { }\r\n        public static Singleton GetInstance()\r\n        {\r\n            if(instance==null)\r\n            {\r\n                instance = new Singleton();\r\n            }\r\n            return instance;\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Singleton s1 = Singleton.GetInstance();\r\n            Singleton s2 = Singleton.GetInstance();\r\n            if(s1==s2)\r\n            {\r\n                Console.WriteLine(\"两个对象是相同的实例。\");\r\n            }\r\n            Console.Read();\r\n        }\r\n    }\r\n}					\r\n					</pre>\r\n					<p>输出结果：两个对象是相同的实例。</p>');
INSERT INTO `designpatterns` VALUES ('4', '建造者模式', '建造者模式（Builder Pattern），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。', 'images/builder.gif', '<p>①建造者模式的使用使得产品的内部表象可以独立的变化，使用建造者模式可以使客户端不必知道产品内部组成的细节。</p>\r\n					<p>②每一个Builder都相对独立，与其他的Builder无关。</p>\r\n					<p>③模式建造的最终产品更容易控制。</p>', '<p>①产品必须有共同点，范围有限制。</p>\r\n					<p>②如内部变化复杂，会有很多的建造类。</p>', '<p>①需要生成的产品对象有复杂的内部结构。</p>\r\n					<p>②需要生成的产品对象的属性相互依赖，建造者模式可以强迫生成顺序。</p>\r\n					<p>③在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到。</p>', '<p>分离整体构建算法和部件构造</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Builder\r\n{\r\n    class Product\r\n    {\r\n        private List<string> _parts = new List<string>();\r\n\r\n        public void Add(string part)\r\n        {\r\n            _parts.Add(part);\r\n        }\r\n\r\n        public void Show()\r\n        {\r\n            Console.WriteLine(\"\\n产品 创建 -------\");\r\n            foreach (string part in _parts)\r\n                Console.WriteLine(part);\r\n        }\r\n    }\r\n    class Director\r\n    {\r\n        public void Construct(Builder builder)\r\n        {\r\n            builder.BuildPartA();\r\n            builder.BuildPartB();\r\n        }\r\n    }\r\n    abstract class Builder\r\n    {\r\n        public abstract void BuildPartA();\r\n        public abstract void BuildPartB();\r\n        public abstract Product GetResult();\r\n    }\r\n    class ConcreteBuilder1 : Builder\r\n    {\r\n        private Product _product = new Product();\r\n\r\n        public override void BuildPartA()\r\n        {\r\n            _product.Add(\"部件A\");\r\n        }\r\n\r\n        public override void BuildPartB()\r\n        {\r\n            _product.Add(\"部件B\");\r\n        }\r\n\r\n        public override Product GetResult()\r\n        {\r\n            return _product;\r\n        }\r\n    }\r\n    class ConcreteBuilder2 : Builder\r\n    {\r\n        private Product _product = new Product();\r\n\r\n        public override void BuildPartA()\r\n        {\r\n            _product.Add(\"部件X\");\r\n        }\r\n\r\n        public override void BuildPartB()\r\n        {\r\n            _product.Add(\"部件Y\");\r\n        }\r\n\r\n        public override Product GetResult()\r\n        {\r\n            return _product;\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Director director = new Director();\r\n\r\n            Builder b1 = new ConcreteBuilder1();\r\n            Builder b2 = new ConcreteBuilder2();\r\n            director.Construct(b1);\r\n            Product p1 = b1.GetResult();\r\n            p1.Show();\r\n\r\n            director.Construct(b2);\r\n            Product p2 = b2.GetResult();\r\n            p2.Show();\r\n            Console.Read();\r\n        }\r\n    }\r\n}			    \r\n				    </pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\nProduct Parts -------\r\nPartA\r\nPartB\r\n\r\nProduct Parts -------\r\nPartX\r\nPartY\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('5', '原型模式', '原型模式（Prototype Pattern）,用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。', 'images/prototype.gif', '<p>①对客户端隐藏具体的实现类型。原型模式的客户端，只知道原型接口的类型，并不知道具体的实现类型，从而减少了客户端对这些具体实现类型的依赖。\r\n					</p>\r\n					<p>②在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态的改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。\r\n					</p>', '<p>深度克隆方法实现会比较困难。原型模式最大的缺点就在于每个原型的子类都必须实现clone的操作，尤其在包含引用类型的对象时，clone方法会比较麻烦，必须要能够递归的让所有的相关对象都要正确的实现克隆。\r\n					</p>', '<p>①如果一个系统想要独立于它想要使用的对象时，可以使用原型模式，让系统只面向接口编程，在系统需要新的对象的时候，可以通过克隆原型来得到</p>\r\n					<p>②如果需要实例化的类是在运行时刻动态指定时，可以使用原型模式，通过克隆原型来得到需要的实例。</p>', '<p>克隆生成对象 </p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Prototype\r\n\r\n{\r\n    abstract class Prototype\r\n    {\r\n        private string _id;\r\n        public Prototype(string id)\r\n        {\r\n            this._id = id;\r\n        }\r\n        public string Id\r\n        {\r\n            get { return _id; }\r\n        }\r\n\r\n        public abstract Prototype Clone();\r\n    }\r\n    class ConcretePrototype1 : Prototype\r\n    {\r\n        public ConcretePrototype1(string id)\r\n          : base(id)\r\n        {\r\n        }\r\n        public override Prototype Clone()\r\n        {\r\n            return (Prototype)this.MemberwiseClone();\r\n        }\r\n    }\r\n    class ConcretePrototype2 : Prototype\r\n    {\r\n        public ConcretePrototype2(string id)\r\n          : base(id)\r\n        {\r\n        }\r\n        public override Prototype Clone()\r\n        {\r\n            return (Prototype)this.MemberwiseClone();\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            ConcretePrototype1 p1 = new ConcretePrototype1(\"I\");\r\n            ConcretePrototype1 c1 = (ConcretePrototype1)p1.Clone();\r\n            Console.WriteLine(\"Cloned: {0}\", c1.Id);\r\n\r\n            ConcretePrototype2 p2 = new ConcretePrototype2(\"II\");\r\n            ConcretePrototype2 c2 = (ConcretePrototype2)p2.Clone();\r\n            Console.WriteLine(\"Cloned: {0}\", c2.Id);\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n\r\n					</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\nCloned: I\r\nCloned: II					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('6', '适配器模式', '适配器模式（Adapter Pattern）,将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。', 'images/adapter.gif', '<p>①更好的复用性。<br>\r\n					②更好的可扩展性。</p>', '<p>过多地使用适配器会让系统非常凌乱，不易整体进行把握。</p>', '<p>复用于一些现存的类，但是接口又与复用环境不一致的情况。在遗留代码复用，类库迁移等方面非常有用。</p>', '<p>转换匹配，复用功能</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace 适配器模式\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Target target = new Adapter();\r\n            target.Request();\r\n\r\n            Console.Read();\r\n\r\n        }\r\n    }\r\n\r\n    class Target\r\n    {\r\n        public virtual void Request()\r\n        {\r\n            Console.WriteLine(\"普通请求\");\r\n        }\r\n    }\r\n\r\n    class Adaptee\r\n    {\r\n        public void SpecificRequest()\r\n        {\r\n            Console.WriteLine(\"特殊请求\");\r\n        }\r\n    }\r\n\r\n    class Adapter : Target\r\n    {\r\n        private Adaptee adaptee = new Adaptee();\r\n\r\n        public override void Request()\r\n        {\r\n            adaptee.SpecificRequest();\r\n        }\r\n    }\r\n}\r\n					\r\n					</pre>\r\n					<p>输出结果：<br>\r\n					特殊请求</p>');
INSERT INTO `designpatterns` VALUES ('7', '桥接模式', '桥接模式（Bridge Pattern），将抽象部分与它的实现部分分离，使它们都可以独立的变化。', 'images/bridge.gif', '<p>①抽象和实现的分离。</p>\r\n					<p>②优秀的扩展能力。</p>\r\n					<p>③实现细节对客户透明。</p>', '<p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>', '<p>①如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</p>\r\n					<p>②对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</p>\r\n					<p>③一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>', '<p>分离抽象和实现</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace Bridge\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Abstraction ab = new RefinedAbstraction();\r\n            ab.Implementor = new ConcreteImplementorA();\r\n            ab.Operation();\r\n            ab.Implementor = new ConcreteImplementorB();\r\n            ab.Operation();\r\n\r\n            Console.Read();\r\n\r\n        }\r\n    }\r\n    class Abstraction\r\n    {\r\n        protected Implementor implementor;\r\n        public Implementor Implementor\r\n        {\r\n            set { implementor = value; }\r\n        }\r\n\r\n        public virtual void Operation()\r\n        {\r\n            implementor.Operation();\r\n        }\r\n    }\r\n    abstract class Implementor\r\n    {\r\n        public abstract void Operation();\r\n    }\r\n    class RefinedAbstraction : Abstraction\r\n    {\r\n        public override void Operation()\r\n        {\r\n            implementor.Operation();\r\n        }\r\n    }\r\n    class ConcreteImplementorA : Implementor\r\n    {\r\n        public override void Operation()\r\n        {\r\n            Console.WriteLine(\"具体实现A的方法执行\");\r\n        }\r\n    }\r\n    class ConcreteImplementorB : Implementor\r\n    {\r\n        public override void Operation()\r\n        {\r\n            Console.WriteLine(\"具体实现B的方法执行\");\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n具体实现A的方法执行\r\n具体实现B的方法执行					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('8', '工厂方法模式', '工厂模式（Factory Pattern）定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。', 'images/factory.gif', '<p>①可以在不知具体实现的情况下编程。工厂方法模式可以让你在实现功能的时候，如果需要某个产品对象，只需要使用产品的接口即可，而无需关心具体的实现。选择具体实现的任务延迟到子类去完成。\r\n					</p>\r\n					<p>②更容易扩展对象的新版本。工厂方法给子类提供了一个挂钩，使得扩展新的对象版本变得非常容易。比如上面示例的参数化工厂方法实现中，扩展一个新的导出Xml文件格式的实现，已有的代码都不会改变，只要新加入一个子类来提供新的工厂方法实现，然后在客户端使用这个新的子类即可。</p>\r\n					<p>③连接平行的类层次。工厂方法除了创造产品对象外，在连接平行的类层次上也大显身手。\r\n					</p>', '<p>具体产品对象和工厂方法的耦合性。在工厂方法模式里面，工厂方法是需要创建产品对象的，也就是需要选择具体的产品对象，并创建它们的实例，因此具体产品对象和工厂方法是耦合的。</p>', '<p>①如果一个类需要创建某个接口的对象，但是又不知道具体的实现，这种情况可以选用工厂方法模式，把创建对象的工作延迟到子类中实现。</p>\r\n					<p>②如果一个类本身就希望由他的子类来创建所需的对象的时候，应该使用工厂方法模式</p>', '<p>延迟到子类来选择实现</p>', '<pre>\r\nusing System;\r\n \r\nnamespace DoFactory.GangOfFour.Factory.Structural\r\n{\r\n  class MainApp\r\n  {\r\n    static void Main()\r\n    {\r\n      Creator[] creators = new Creator[2];\r\n \r\n      creators[0] = new ConcreteCreatorA();\r\n      creators[1] = new ConcreteCreatorB();\r\n \r\n      foreach (Creator creator in creators)\r\n      {\r\n        Product product = creator.FactoryMethod();\r\n        Console.WriteLine(\"Created {0}\",\r\n          product.GetType().Name);\r\n      }\r\n \r\n      Console.ReadKey();\r\n    }\r\n  }\r\n\r\n  abstract class Product\r\n  {\r\n  }\r\n\r\n  class ConcreteProductA : Product\r\n  {\r\n  }\r\n\r\n  class ConcreteProductB : Product\r\n  {\r\n  }\r\n\r\n  abstract class Creator\r\n  {\r\n    public abstract Product FactoryMethod();\r\n  }\r\n\r\n  class ConcreteCreatorA : Creator\r\n  {\r\n    public override Product FactoryMethod()\r\n    {\r\n      return new ConcreteProductA();\r\n    }\r\n  }\r\n  class ConcreteCreatorB : Creator\r\n  {\r\n    public override Product FactoryMethod()\r\n    {\r\n      return new ConcreteProductB();\r\n    }\r\n  }\r\n}				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\nCreated ConcreteProductA\r\nCreated ConcreteProductB					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('9', '组合模式', '组合模式（Composite Pattern），又叫部分整体模式，将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。', 'images/composite.gif', '<p>①定义了包含基本对象和组合对象的类层次结构</p>\r\n					<p>②统一了组合对象和叶子对象</p>\r\n					<p>③简化了客户端调用</p>\r\n					<p>④更容易扩展</p>', '<p>很难限制组合中的组件类型，不能依靠编译期的类型约束来完成，必须在运行期间动态检测。</p>', '<p>部分、整体场景，如绘图编辑器，图形捕捉系统。</p>', '<p>统一叶子对象和组合对象</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Composite\r\n{\r\n    abstract class Component\r\n    {\r\n        protected string name;\r\n        public Component(string name)\r\n        {\r\n            this.name = name;\r\n        }\r\n        public abstract void Add(Component c);\r\n        public abstract void Remove(Component c);\r\n        public abstract void Display(int depth);\r\n    }\r\n    class Leaf:Component\r\n    {\r\n        public Leaf(string name) : base(name) { }\r\n        public override void Add(Component c)\r\n        {\r\n            Console.WriteLine(\"Cannot add to a leaf\");\r\n        }\r\n        public override void Remove(Component c)\r\n        {\r\n            Console.WriteLine(\"Cannot remove from a leaf\");\r\n        }\r\n        public override void Display(int depth)\r\n        {\r\n            Console.WriteLine(new String(\' \', depth) + name);\r\n        }\r\n    }\r\n    class Composite:Component\r\n    {\r\n        private List<Component> chirldren = new List<Component>();\r\n        public Composite(string name) : base(name) { }\r\n        public override void Add(Component c)\r\n        {\r\n            chirldren.Add(c);\r\n        }\r\n        public override void Remove(Component c)\r\n        {\r\n            chirldren.Remove(c);\r\n        }\r\n        public override void Display(int depth)\r\n        {\r\n            Console.WriteLine(new String(\' \', depth) + name);\r\n            foreach(Component component in chirldren)\r\n            {\r\n                component.Display(depth + 2);\r\n            }\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Composite root = new Composite(\"服装\");\r\n            Composite comp = new Composite(\"男装\");\r\n            comp.Add(new Leaf(\"衬衣\"));\r\n            comp.Add(new Leaf(\"夹克\"));\r\n            root.Add(comp);\r\n            Composite comp2 = new Composite(\"女装\");\r\n            comp2.Add(new Leaf(\"裙子\"));\r\n            comp2.Add(new Leaf(\"套装\"));\r\n            root.Add(comp2);\r\n            root.Display(1);\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n 服装\r\n   男装\r\n     衬衣\r\n     夹克\r\n   女装\r\n     裙子\r\n     套装					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('10', '装饰模式', '装饰模式（Decorator Pattern）动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。', 'images/decorator.gif', '<p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>', '<p>多层装饰比较复杂。</p>', '<p>扩展一个类的功能。动态增加功能，动态撤销。</p>', '<p>动态组合。动态是手段，组合是目的。</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace 装饰模式\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            ConcreteComponent c = new ConcreteComponent();\r\n            ConcreteDecoratorA d1 = new ConcreteDecoratorA();\r\n            ConcreteDecoratorB d2 = new ConcreteDecoratorB();\r\n\r\n            d1.SetComponent(c);\r\n            d2.SetComponent(d1);\r\n\r\n            d2.Operation();\r\n\r\n            Console.Read();\r\n        }\r\n    }\r\n\r\n    abstract class Component\r\n    {\r\n        public abstract void Operation();\r\n    }\r\n\r\n    class ConcreteComponent : Component\r\n    {\r\n        public override void Operation()\r\n        {\r\n            Console.WriteLine(\"具体对象的操作\");\r\n        }\r\n    }\r\n\r\n    abstract class Decorator : Component\r\n    {\r\n        protected Component component;\r\n\r\n        public void SetComponent(Component component)\r\n        {\r\n            this.component = component;\r\n        }\r\n\r\n        public override void Operation()\r\n        {\r\n            if (component != null)\r\n            {\r\n                component.Operation();\r\n            }\r\n        }\r\n    }\r\n\r\n    class ConcreteDecoratorA : Decorator\r\n    {\r\n        private string addedState;\r\n\r\n        public override void Operation()\r\n        {\r\n            base.Operation();\r\n            addedState = \"New State\";\r\n            Console.WriteLine(\"具体装饰对象A的操作\");\r\n        }\r\n    }\r\n\r\n    class ConcreteDecoratorB : Decorator\r\n    {\r\n\r\n        public override void Operation()\r\n        {\r\n            base.Operation();\r\n            AddedBehavior();\r\n            Console.WriteLine(\"具体装饰对象B的操作\");\r\n        }\r\n\r\n        private void AddedBehavior()\r\n        {\r\n\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n具体对象的操作\r\n具体装饰对象A的操作\r\n具体装饰对象B的操作					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('11', '外观模式', '外观模式（Facade Pattern）为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。', 'images/facade.gif', '<p>①屏蔽了外部客户端和系统内部模块的交互。</p>\r\n					<p>②Facade的功能可以被多个客户端调用，可以实现复用（功能的共享）</p>\r\n					<p>③对使用Facade的人员来说，Facade大大的节省了他们的学习成本。</p>', '<p>不符合开放-封闭原则。</p>', '<p>①如果你希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式，使用外观对象来实现大部分客户需要的功能，从而简化客户的使用</p>\r\n					<p>②如果想要让客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象来将这个子系统与它的客户分离开来，从而提高子系统的独立性和可移植性</p>\r\n					<p>③如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系</p>', '<p>封装交互，简化调用</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace Facade\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Facade facade = new Facade();\r\n\r\n            facade.MethodA();\r\n            facade.MethodB();\r\n\r\n            Console.Read();\r\n\r\n        }\r\n    }\r\n    class SubSystemOne\r\n    {\r\n        public void MethodOne()\r\n        {\r\n            Console.WriteLine(\" 子系统方法一\");\r\n        }\r\n    }\r\n    class SubSystemTwo\r\n    {\r\n        public void MethodTwo()\r\n        {\r\n            Console.WriteLine(\" 子系统方法二\");\r\n        }\r\n    }\r\n    class SubSystemThree\r\n    {\r\n        public void MethodThree()\r\n        {\r\n            Console.WriteLine(\" 子系统方法三\");\r\n        }\r\n    }\r\n    class SubSystemFour\r\n    {\r\n        public void MethodFour()\r\n        {\r\n            Console.WriteLine(\" 子系统方法四\");\r\n        }\r\n    }\r\n    class Facade\r\n    {\r\n        private SubSystemOne _one;\r\n        private SubSystemTwo _two;\r\n        private SubSystemThree _three;\r\n        private SubSystemFour _four;\r\n\r\n        public Facade()\r\n        {\r\n            _one = new SubSystemOne();\r\n            _two = new SubSystemTwo();\r\n            _three = new SubSystemThree();\r\n            _four = new SubSystemFour();\r\n        }\r\n\r\n        public void MethodA()\r\n        {\r\n            Console.WriteLine(\"\\n方法组A() ---- \");\r\n            _one.MethodOne();\r\n            _two.MethodTwo();\r\n            _four.MethodFour();\r\n        }\r\n\r\n        public void MethodB()\r\n        {\r\n            Console.WriteLine(\"\\n方法组B() ---- \");\r\n            _two.MethodTwo();\r\n            _three.MethodThree();\r\n        }\r\n    }\r\n}				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n\r\n方法组A() ----\r\n 子系统方法一\r\n 子系统方法二\r\n 子系统方法四\r\n\r\n方法组B() ----\r\n 子系统方法二\r\n 子系统方法三\r\n					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('12', '享元模式', '享元模式（Flyweight Pattern）,运用共享技术有效地支持大量细粒度的对象。', 'images/flyweight.gif', '<p>大大减少对象的创建，降低系统的内存，使效率提高。</p>', '<p>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>', '<p>①系统有大量相似对象。</p>\r\n					<p>②需要缓冲池的场景。</p>', '<p>①系统有大量相似对象。</p>\r\n					<p>②需要缓冲池的场景。</p>', '<pre>\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace Flyweight\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            int extrinsicstate = 22;\r\n\r\n            FlyweightFactory factory = new FlyweightFactory();\r\n\r\n            Flyweight fx = factory.GetFlyweight(\"X\");\r\n            fx.Operation(--extrinsicstate);\r\n\r\n            Flyweight fy = factory.GetFlyweight(\"Y\");\r\n            fy.Operation(--extrinsicstate);\r\n\r\n            Flyweight fz = factory.GetFlyweight(\"Z\");\r\n            fz.Operation(--extrinsicstate);\r\n\r\n            UnsharedConcreteFlyweight fu = new\r\n              UnsharedConcreteFlyweight();\r\n\r\n            fu.Operation(--extrinsicstate);\r\n\r\n            Console.Read();\r\n\r\n        }\r\n    }\r\n    class FlyweightFactory\r\n    {\r\n        private Hashtable flyweights = new Hashtable();\r\n\r\n        // Constructor\r\n        public FlyweightFactory()\r\n        {\r\n            flyweights.Add(\"X\", new ConcreteFlyweight());\r\n            flyweights.Add(\"Y\", new ConcreteFlyweight());\r\n            flyweights.Add(\"Z\", new ConcreteFlyweight());\r\n        }\r\n\r\n        public Flyweight GetFlyweight(string key)\r\n        {\r\n            return ((Flyweight)flyweights[key]);\r\n        }\r\n    }\r\n    abstract class Flyweight\r\n    {\r\n        public abstract void Operation(int extrinsicstate);\r\n    }\r\n    class ConcreteFlyweight : Flyweight\r\n    {\r\n        public override void Operation(int extrinsicstate)\r\n        {\r\n            Console.WriteLine(\"具体Flyweight: \" + extrinsicstate);\r\n        }\r\n    }\r\n    class UnsharedConcreteFlyweight : Flyweight\r\n    {\r\n        public override void Operation(int extrinsicstate)\r\n        {\r\n            Console.WriteLine(\"不共享的具体Flyweight: \" +\r\n              extrinsicstate);\r\n        }\r\n    }\r\n}\r\n\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n具体Flyweight: 21\r\n具体Flyweight: 20\r\n具体Flyweight: 19\r\n不共享的具体Flyweight: 18					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('13', '代理模式', '代理模式（Proxy Pattern）,为其他对象提供一种代理以控制对这个对象的访问。', 'images/proxy.gif', '<p>①职责清晰</p>\r\n					<p>②高扩展性</p>\r\n					<p>③智能化</p>', '<p>①由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</p>\r\n					<p>②实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>', '<p>①需要为一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理</p>\r\n					<p>②需要按照需要创建开销很大的对象的时候，可以使用虚代理</p>\r\n					<p>③需要控制对原始对象的访问的时候，可以使用保护代理</p>\r\n					<p>④需要在访问对象的时候执行一些附加操作的时候，可以使用智能指引代理</p>', '<p>控制对象访问</p>', '<pre>\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace Proxy\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Proxy proxy = new Proxy();\r\n            proxy.Request();\r\n\r\n            Console.Read();\r\n\r\n        }\r\n    }\r\n    abstract class Subject\r\n    {\r\n        public abstract void Request();\r\n    }\r\n    class RealSubject : Subject\r\n    {\r\n        public override void Request()\r\n        {\r\n            Console.WriteLine(\"真实的请求\");\r\n        }\r\n    }\r\n    class Proxy : Subject\r\n    {\r\n        private RealSubject _realSubject;\r\n\r\n        public override void Request()\r\n        {\r\n            if (_realSubject == null)\r\n            {\r\n                _realSubject = new RealSubject();\r\n            }\r\n\r\n            _realSubject.Request();\r\n        }\r\n    }\r\n}\r\n\r\n				\r\n				</pre>\r\n					<p>输出的结果：<br>\r\n					真实的请求</p>');
INSERT INTO `designpatterns` VALUES ('14', '责任链模式', '责任链模式（Chain of Responsibility Pattern），避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。', 'images/chain.gif', '<p>①降低耦合度。它将请求的发送者和接收者解耦。</p>\r\n					<p>②简化了对象。使得对象不需要知道链的结构。</p>\r\n					<p>③增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</p>\r\n					<p>④增加新的请求处理类很方便。</p>', '<p>①不能保证请求一定被接收</p>\r\n					<p>②系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 </p>\r\n					<p>③可能不容易观察运行时的特征，有碍于除错。</p>', '<p>①有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。</p>\r\n					<p>②在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</p>\r\n					<p>③可动态指定一组对象处理请求。</p>', '<p>分离职责，动态组合</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Responsibility\r\n{\r\n    abstract class Handler\r\n    {\r\n        protected Handler successor;\r\n        public void SetSuccessor(Handler successor)\r\n        {\r\n            this.successor = successor;\r\n        }\r\n        public abstract void HandlerRequest(int request);\r\n    }\r\n    class ConcreteHandler1:Handler\r\n    {\r\n        public override void HandlerRequest(int request)\r\n        {\r\n            if(request>=0&&request<10)\r\n            {\r\n                Console.WriteLine(\"{0}处理请求{1}\", this.GetType().Name, request);\r\n            }\r\n            else if(successor!=null)\r\n            {\r\n                successor.HandlerRequest(request);\r\n            }\r\n        }\r\n    }\r\n    class ConcreteHandler2 : Handler\r\n    {\r\n        public override void HandlerRequest(int request)\r\n        {\r\n            if (request >= 10 && request < 20)\r\n            {\r\n                Console.WriteLine(\"{0}处理请求{1}\", this.GetType().Name, request);\r\n            }\r\n            else if (successor != null)\r\n            {\r\n                successor.HandlerRequest(request);\r\n            }\r\n        }\r\n    }\r\n    class ConcreteHandler3 : Handler\r\n    {\r\n        public override void HandlerRequest(int request)\r\n        {\r\n            if (request >=20 && request < 30)\r\n            {\r\n                Console.WriteLine(\"{0}处理请求{1}\", this.GetType().Name, request);\r\n            }\r\n            else if (successor != null)\r\n            {\r\n                successor.HandlerRequest(request);\r\n            }\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Handler h1 = new ConcreteHandler1();\r\n            Handler h2 = new ConcreteHandler2();\r\n            Handler h3 = new ConcreteHandler3();\r\n            h1.SetSuccessor(h2);\r\n            h2.SetSuccessor(h3);\r\n            int[] requests = { 2, 5, 14, 22, 18, 3, 27, 20 };\r\n            foreach(int request in requests)\r\n            {\r\n                h1.HandlerRequest(request);\r\n            }\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\nConcreteHandler1处理请求2\r\nConcreteHandler1处理请求5\r\nConcreteHandler2处理请求14\r\nConcreteHandler3处理请求22\r\nConcreteHandler2处理请求18\r\nConcreteHandler1处理请求3\r\nConcreteHandler3处理请求27\r\nConcreteHandler3处理请求20');
INSERT INTO `designpatterns` VALUES ('15', '命令模式', '命令模式（Command Pattern）将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。', 'images/command.gif', '<p>①使新的命令很容易的被加入到系统里；</p>\r\n					<p>②允许接受请求的一方决定是否要否决请求；</p>\r\n					<p>③能比较容易的设计一个命令队列；</p>\r\n					<p>④可以容易的实现对请求的Undo和Redo</p>\r\n					<p>⑤在需要的情况下，可以较容易的将命令计入日志</p>\r\n					<p>⑥命令模式把请求一个操作的对象知道怎么执行一个操作的对象分割开；</p>\r\n					<p>⑦命令类与其他任何别的类一样，可以修改和推广。</p>', '<p>使用命令模式可能会导致某些系统有过多的具体命令类。</p>', '<p>①请求队列化，（封装命令集合）</p>\r\n					<p>②需要支持取消操作，可以使用命令模式，通过管理命令对象，能很容易的实现命令的恢复和重做的功能。（与备忘录模式结合使用）</p>\r\n					<p>③在需要事务的系统中，可以选用命令模式，命令模式提供了对事务进行建模的方法。</p>', '<p>封装请求</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Commond\r\n{\r\n    abstract class Command\r\n    {\r\n        protected Receiver receiver;\r\n        public Command(Receiver receiver)\r\n        {\r\n            this.receiver = receiver;\r\n        }\r\n\r\n        public abstract void Execute();\r\n    }\r\n    class ConcreteCommand : Command\r\n    {\r\n        public ConcreteCommand(Receiver receiver) :\r\n          base(receiver)\r\n        {\r\n        }\r\n\r\n        public override void Execute()\r\n        {\r\n            receiver.Action();\r\n        }\r\n    }\r\n    class Receiver\r\n    {\r\n        public void Action()\r\n        {\r\n            Console.WriteLine(\"执行请求！\");\r\n        }\r\n    }\r\n    class Invoker\r\n    {\r\n        private Command _command;\r\n\r\n        public void SetCommand(Command command)\r\n        {\r\n            this._command = command;\r\n        }\r\n\r\n        public void ExecuteCommand()\r\n        {\r\n            _command.Execute();\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Receiver receiver = new Receiver();\r\n            Command command = new ConcreteCommand(receiver);\r\n            Invoker invoker = new Invoker();\r\n            invoker.SetCommand(command);\r\n            invoker.ExecuteCommand();\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：<br>\r\n					执行请求！</p>');
INSERT INTO `designpatterns` VALUES ('16', '迭代器模式', '迭代器模式（Iterator Pattern），提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。', 'images/iterator.gif', '<p>①它支持以不同的方式遍历一个聚合对象。</p>\r\n					<p>②迭代器简化了聚合类。</p>\r\n					<p>③在同一个聚合上可以有多个遍历。</p>\r\n					<p>④在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>', '<p>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>', '<p>①访问一个聚合对象的内容而无须暴露它的内部表示。</p>\r\n					<p>②需要为聚合对象提供多种遍历方式。</p>\r\n					<p>③为遍历不同的聚合结构提供一个统一的接口。</p>', '<p>封装遍历</p>', '<pre>\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Iterator\r\n{\r\n    abstract class Aggregate\r\n    {\r\n        public abstract Iterator CreateIterator();\r\n    }\r\n    class ConcreteAggregate : Aggregate\r\n    {\r\n        private ArrayList _items = new ArrayList();\r\n\r\n        public override Iterator CreateIterator()\r\n        {\r\n            return new ConcreteIterator(this);\r\n        }\r\n        public int Count\r\n        {\r\n            get { return _items.Count; }\r\n        }\r\n        public object this[int index]\r\n        {\r\n            get { return _items[index]; }\r\n            set { _items.Insert(index, value); }\r\n        }\r\n    }\r\n    abstract class Iterator\r\n    {\r\n        public abstract object First();\r\n        public abstract object Next();\r\n        public abstract bool IsDone();\r\n        public abstract object CurrentItem();\r\n    }\r\n    class ConcreteIterator : Iterator\r\n    {\r\n        private ConcreteAggregate _aggregate;\r\n        private int _current = 0;\r\n        public ConcreteIterator(ConcreteAggregate aggregate)\r\n        {\r\n            this._aggregate = aggregate;\r\n        }\r\n        public override object First()\r\n        {\r\n            return _aggregate[0];\r\n        }\r\n        public override object Next()\r\n        {\r\n            object ret = null;\r\n            if (_current < _aggregate.Count - 1)\r\n            {\r\n                ret = _aggregate[++_current];\r\n            }\r\n\r\n            return ret;\r\n        }\r\n\r\n        public override object CurrentItem()\r\n        {\r\n            return _aggregate[_current];\r\n        }\r\n\r\n        public override bool IsDone()\r\n        {\r\n            return _current >= _aggregate.Count;\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            ConcreteAggregate a = new ConcreteAggregate();\r\n            a[0] = \"Item A\";\r\n            a[1] = \"Item B\";\r\n            a[2] = \"Item C\";\r\n            a[3] = \"Item D\";\r\n            Iterator i = a.CreateIterator();\r\n\r\n            Console.WriteLine(\"Iterating over collection:\");\r\n\r\n            object item = i.First();\r\n            while (item != null)\r\n            {\r\n                Console.WriteLine(item);\r\n                item = i.Next();\r\n            }\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\nIterating over collection:\r\nItem A\r\nItem B\r\nItem C\r\nItem D					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('17', '中介者模式', '中介者模式（Mediator Pattern）,用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。', 'images/mediator.gif', '<p>①将多对多的通信转化为一对多的通信，降低了系统的复杂性。</p>\r\n					<p>②中介者还获得系统解耦的特性，降低了系统的耦合性。</p>\r\n					<p>③中介者模式控制集中，集中的优势就是便于管理。</p>', '<p>中介者会庞大，变得复杂难以维护。</p>', '<p>①系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。</p>\r\n					<p>②想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>', '<p>封装交互</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Mediator\r\n{\r\n    abstract class Mediator\r\n    {\r\n        public abstract void Send(string message, Colleague colleague);\r\n    }\r\n    abstract class Colleague\r\n    {\r\n        protected Mediator mediator;\r\n        public Colleague(Mediator mediator)\r\n        {\r\n            this.mediator = mediator;\r\n        }\r\n    }\r\n    class ConcreteMediator:Mediator\r\n    {\r\n        private ConcreteColleague1 colleague1;\r\n        private ConcreteColleague2 colleague2;\r\n        public ConcreteColleague1 Colleague1\r\n        {\r\n            set { colleague1 = value; }\r\n        }\r\n        public ConcreteColleague2 Colleague2\r\n        {\r\n            set { colleague2 = value; }\r\n        }\r\n        public override void Send(string message, Colleague colleague)\r\n        {\r\n            if(colleague==colleague1)\r\n            {\r\n                colleague2.Notify(message);\r\n            }\r\n            else\r\n            {\r\n                colleague1.Notify(message);\r\n            }\r\n        }\r\n    }\r\n    class ConcreteColleague1:Colleague\r\n    {\r\n        public ConcreteColleague1(Mediator mediator):base(mediator){ }\r\n        public void Send(string message)\r\n        {\r\n            mediator.Send(message, this);\r\n        }\r\n        public void Notify(string message)\r\n        {\r\n            Console.WriteLine(\"同事1得到消息：\" + message);\r\n        }\r\n    }\r\n    class ConcreteColleague2 : Colleague\r\n    {\r\n        public ConcreteColleague2(Mediator mediator) : base(mediator) { }\r\n        public void Send(string message)\r\n        {\r\n            mediator.Send(message, this);\r\n        }\r\n        public void Notify(string message)\r\n        {\r\n            Console.WriteLine(\"同事2得到消息：\" + message);\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            ConcreteMediator m = new ConcreteMediator();\r\n            ConcreteColleague1 c1 = new ConcreteColleague1(m);\r\n            ConcreteColleague2 c2 = new ConcreteColleague2(m);\r\n            m.Colleague1 = c1;\r\n            m.Colleague2 = c2;\r\n            c1.Send(\"吃过饭了吗？\");\r\n            c2.Send(\"没有呢，你打算请客？\");\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n同事2得到消息：吃过饭了吗？\r\n同事1得到消息：没有呢，你打算请客？					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('18', '备忘录模式', '备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。', 'images/memento.gif', '<p>①使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当的保持封装的边界。</p>\r\n					<p>②本模式简化了发起人类</p>\r\n					<p>③用存储起来的备忘录将状态复苏。</p>', '<p>①资源消耗上面备忘录对象会很大。</p>\r\n					<p>②无法提醒用户一个操作是否很大。</p>', '<p>如果必须保存一个对象在某一时刻的全部或部分状态，方便在以后需要的时候，可以把该对象恢复到先前的状态，可以使用备忘录模式。</p>', '<p>保存和恢复内部状态</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Memento\r\n{\r\n    class Originator\r\n    {\r\n        private string _state;\r\n        public string State\r\n        {\r\n            get { return _state; }\r\n            set\r\n            {\r\n                _state = value;\r\n                Console.WriteLine(\"State = \" + _state);\r\n            }\r\n        }\r\n        public Memento CreateMemento()\r\n        {\r\n            return (new Memento(_state));\r\n        }\r\n        public void SetMemento(Memento memento)\r\n        {\r\n            Console.WriteLine(\"Restoring state...\");\r\n            State = memento.State;\r\n        }\r\n    }\r\n    class Memento\r\n    {\r\n        private string _state;\r\n        public Memento(string state)\r\n        {\r\n            this._state = state;\r\n        }\r\n        public string State\r\n        {\r\n            get { return _state; }\r\n        }\r\n    }\r\n    class Caretaker\r\n    {\r\n        private Memento _memento;\r\n        public Memento Memento\r\n        {\r\n            set { _memento = value; }\r\n            get { return _memento; }\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Originator o = new Originator();\r\n            o.State = \"On\";\r\n            Caretaker c = new Caretaker();\r\n            c.Memento = o.CreateMemento();\r\n            o.State = \"Off\";\r\n            o.SetMemento(c.Memento);\r\n\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\nState = On\r\nState = Off\r\nRestoring state...\r\nState = On					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('19', '观察者模式', '观察者模式（Observer Pattern），又叫发布-订阅模式、模型-视图模式、源-监听器模式、从属者模式，它是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。', 'images/observer.gif', '<p>①观察者模式实现了观察者和目标之间的抽象耦合</p>\r\n					<p>②观察者模式实现了动态联动</p>\r\n					<p>③观察者模式支持广播通信</p>', '<p>观察者模式可能会引起无谓的操作</p>', '<p>①当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化，那么就可以选用观察者模式，将这两者封装成观察者和目标对象，当目标对象变化的时候，依赖于它的观察者对象也会发生相应的变化。这样就把抽象模型的这两个方面分离开了，使得它们可以独立的改变和复用。</p>\r\n					<p>②如果在更改一个对象的时候，需要同时连带改变其它的对象，而且不知道究竟应该有多少对象需要被连带改变，这种情况可以选用观察者模式，被更改的那一个对象很明显就相当于是目标对象，而需要连带修改的多个其它对象，就作为多个观察者对象了。</p>\r\n					<p>③当一个对象必须通知其它的对象，但是你又希望这个对象和其它被它通知的对象是松散耦合的，也就是说这个对象其实不想知道具体被通知的对象，这种情况可以选用观察者模式，这个对象就相当于是目标对象，而被它通知的对象就是观察者对象了。</p>', '<p>触发联动</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Observer\r\n{\r\n    abstract class Subject\r\n    {\r\n        private List<Observer> _observers = new List<Observer>();\r\n\r\n        public void Attach(Observer observer)\r\n        {\r\n            _observers.Add(observer);\r\n        }\r\n\r\n        public void Detach(Observer observer)\r\n        {\r\n            _observers.Remove(observer);\r\n        }\r\n\r\n        public void Notify()\r\n        {\r\n            foreach (Observer o in _observers)\r\n            {\r\n                o.Update();\r\n            }\r\n        }\r\n    }\r\n    class ConcreteSubject : Subject\r\n    {\r\n        private string _subjectState;\r\n\r\n        public string SubjectState\r\n        {\r\n            get { return _subjectState; }\r\n            set { _subjectState = value; }\r\n        }\r\n    }\r\n    abstract class Observer\r\n    {\r\n        public abstract void Update();\r\n    }\r\n    class ConcreteObserver : Observer\r\n    {\r\n        private string _name;\r\n        private string _observerState;\r\n        private ConcreteSubject _subject;\r\n        public ConcreteObserver(\r\n          ConcreteSubject subject, string name)\r\n        {\r\n            this._subject = subject;\r\n            this._name = name;\r\n        }\r\n\r\n        public override void Update()\r\n        {\r\n            _observerState = _subject.SubjectState;\r\n            Console.WriteLine(\"观察者 {0}的新状态是 {1}\",\r\n              _name, _observerState);\r\n        }\r\n        public ConcreteSubject Subject\r\n        {\r\n            get { return _subject; }\r\n            set { _subject = value; }\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            ConcreteSubject s = new ConcreteSubject();\r\n            s.Attach(new ConcreteObserver(s, \"X\"));\r\n            s.Attach(new ConcreteObserver(s, \"Y\"));\r\n            s.Attach(new ConcreteObserver(s, \"Z\"));\r\n            s.SubjectState = \"ABC\";\r\n            s.Notify();\r\n\r\n            Console.Read();\r\n        }\r\n    }\r\n}				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n观察者 X的新状态是 ABC\r\n观察者 Y的新状态是 ABC\r\n观察者 Z的新状态是 ABC					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('20', '策略模式', '策略模式（Strategy Pattern）定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。此模式让算法的变化，不会影响到使用算法的客户。', 'images/strategy.gif', '<p>①定义一系列算法</p>\r\n					<p>②避免多重条件语句</p>\r\n					<p>③更好的扩展性</p>', '<p>①客户必须了解每种策略的不同</p>\r\n					<p>②增加了对象数目</p>', '<p>①出现有许多相关的类，仅仅是行为有差别的情况，可以使用策略模式来使用多个行为中的一个来配置一个类的方法，实现算法动态切换</p>\r\n					<p>②出现同一个算法，有很多不同的实现的情况，可以使用策略模式来把这些“不同的实现”实现成为一个算法的类层次</p>\r\n					<p>③需要封装算法中，与算法相关的数据的情况，可以使用策略模式来避免暴露这些跟算法相关的数据结</p>\r\n					<p>④出现抽象一个定义了很多行为的类，并且是通过多个if-else语句来选择这些行为的情况，可以使用策略模式来代替这些条件语句</p>', '<p>分离算法，选择实现</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Strategy\r\n{\r\n    abstract class Strategy\r\n    {\r\n        public abstract void AlgorithmInterface();\r\n    }\r\n    class ConcreteStrategyA : Strategy\r\n    {\r\n        public override void AlgorithmInterface()\r\n        {\r\n            Console.WriteLine(\r\n              \"算法A的实现\");\r\n        }\r\n    }\r\n    class ConcreteStrategyB : Strategy\r\n    {\r\n        public override void AlgorithmInterface()\r\n        {\r\n            Console.WriteLine(\r\n              \"算法B的实现\");\r\n        }\r\n    }\r\n    class ConcreteStrategyC : Strategy\r\n    {\r\n        public override void AlgorithmInterface()\r\n        {\r\n            Console.WriteLine(\r\n              \"算法C的实现\");\r\n        }\r\n    }\r\n    class Context\r\n    {\r\n        private Strategy _strategy;\r\n        public Context(Strategy strategy)\r\n        {\r\n            this._strategy = strategy;\r\n        }\r\n\r\n        public void ContextInterface()\r\n        {\r\n            _strategy.AlgorithmInterface();\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Context context;\r\n            context = new Context(new ConcreteStrategyA());\r\n            context.ContextInterface();\r\n\r\n            context = new Context(new ConcreteStrategyB());\r\n            context.ContextInterface();\r\n\r\n            context = new Context(new ConcreteStrategyC());\r\n            context.ContextInterface();\r\n\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n算法A的实现\r\n算法B的实现\r\n算法C的实现					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('21', '状态模式', '状态模式（State Pattern）允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。', 'images/state.gif', '<p>①封装了转换规则。</p>\r\n					<p>②枚举可能的状态，在枚举状态之前需要确定状态种类。</p>\r\n					<p>③将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</p>\r\n					<p>④允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</p>\r\n					<p>⑤可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>', '<p>①状态模式的使用必然会增加系统类和对象的个数。</p>\r\n					<p>②状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 </p>\r\n					<p>③状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p>', '<p>①行为随状态改变而改变的场景。</p>\r\n					<p>②条件、分支语句的代替者。</p>', '<p>根据状态来分离和选择行为。状态模式是状态驱动，由上下文负责。</p>', '<pre>\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Statecontext\r\n{\r\n    abstract class State\r\n    {\r\n        public abstract void Handle(Context context);\r\n    }\r\n    class ConcreteStateA:State\r\n    {\r\n        public override void Handle(Context context)\r\n        {\r\n            context.State = new ConcreteStateB();\r\n        }\r\n    }\r\n    class ConcreteStateB:State\r\n    {\r\n        public override void Handle(Context context)\r\n        {\r\n            context.State = new ConcreteStateA();\r\n        }\r\n    }\r\n    class Context\r\n    {\r\n        private State state;\r\n        public Context(State state)\r\n        {\r\n            this.state = state;\r\n        }\r\n        public State State\r\n        {\r\n            get { return state; }\r\n            set\r\n            {\r\n                state = value;\r\n                Console.WriteLine(\"当前状态：\" + state.GetType().Name);\r\n            }\r\n        }\r\n        public void Request()\r\n        {\r\n            state.Handle(this);\r\n        }\r\n    }\r\n  \r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Context c = new Context(new ConcreteStateA());\r\n            c.Request();\r\n            c.Request();\r\n            c.Request();\r\n            c.Request();\r\n            Console.Read();\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n当前状态：ConcreteStateB\r\n当前状态：ConcreteStateA\r\n当前状态：ConcreteStateB\r\n当前状态：ConcreteStateA					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('22', '模板模式', '模板模式（Template Pattern）定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。', 'images/template.gif', '					<p>实现代码复用。 模板方法模式是一种实现代码复用的很好的手段。通过把子类的公共功能提炼和抽取，把公共部分放到模板里面去实现。\r\n					</p>', '<p>算法骨架不容易升级。 模板方法模式最基本的功能就是通过模板的制定，把算法骨架完全固定下来。事实上模板和子类是非常耦合的，如果要对模板中的算法骨架进行变更，可能就会要求所有相关的子类进行相应的变化。所以抽取算法骨架的时候要特别小心，尽量确保是不会变化的部分才放到模板中。\r\n					</p>', '<p>①需要固定定义算法骨架，实现一个算法的不变的部分，并把可变的行为留给子类来实现的情况</p>\r\n					<p>②各个子类中具有公共行为，应该抽取出来，集中在一个公共类中去实现，从而避免代码重复</p>\r\n					<p>③需要控制子类扩展的情况。模板方法模式会在特定的点来调用子类的方法，这样只允许在这些点进行扩展</p>', '<p>固定算法骨架。</p>', '<pre>\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace Template\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            AbstractClass aA = new ConcreteClassA();\r\n            aA.TemplateMethod();\r\n\r\n            AbstractClass aB = new ConcreteClassB();\r\n            aB.TemplateMethod();\r\n\r\n            Console.Read();\r\n\r\n        }\r\n    }\r\n    abstract class AbstractClass\r\n    {\r\n        public abstract void PrimitiveOperation1();\r\n        public abstract void PrimitiveOperation2();\r\n        public void TemplateMethod()\r\n        {\r\n            PrimitiveOperation1();\r\n            PrimitiveOperation2();\r\n            Console.WriteLine(\"\");\r\n        }\r\n    }\r\n\r\n    class ConcreteClassA : AbstractClass\r\n    {\r\n        public override void PrimitiveOperation1()\r\n        {\r\n            Console.WriteLine(\"具体类A方法1实现\");\r\n        }\r\n        public override void PrimitiveOperation2()\r\n        {\r\n            Console.WriteLine(\"具体类A方法2实现\");\r\n        }\r\n    }\r\n\r\n    class ConcreteClassB : AbstractClass\r\n    {\r\n        public override void PrimitiveOperation1()\r\n        {\r\n            Console.WriteLine(\"具体类B方法1实现\");\r\n        }\r\n        public override void PrimitiveOperation2()\r\n        {\r\n            Console.WriteLine(\"具体类B方法2实现\");\r\n        }\r\n    }\r\n}\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n具体类A方法1实现\r\n具体类A方法2实现\r\n\r\n具体类B方法1实现\r\n具体类B方法2实现					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('23', '访问者模式', '访问者模式（Visitor Pattern）主要将数据结构与数据操作分离。', 'images/visitor.gif', '<p>①符合单一职责原则。</p>\r\n					<p>②优秀的扩展性。</p>\r\n					<p>③灵活性。</p>', '<p>①具体元素对访问者公布细节，违反了迪米特原则。</p>\r\n					<p>②具体元素变更比较困难。</p>\r\n					<p>③违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p>', '<p>①对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</p>\r\n					<p>②需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。</p>', '<p>预留通路，回调实现。</p>', '<pre>\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace Visited\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            ObjectStructure o = new ObjectStructure();\r\n            o.Attach(new ConcreteElementA());\r\n            o.Attach(new ConcreteElementB());\r\n            ConcreteVisitor1 v1 = new ConcreteVisitor1();\r\n            ConcreteVisitor2 v2 = new ConcreteVisitor2();\r\n            o.Accept(v1);\r\n            o.Accept(v2);\r\n\r\n            Console.Read();\r\n\r\n        }\r\n    }\r\n    abstract class Visitor\r\n    {\r\n        public abstract void VisitConcreteElementA(\r\n          ConcreteElementA concreteElementA);\r\n        public abstract void VisitConcreteElementB(\r\n          ConcreteElementB concreteElementB);\r\n    }\r\n    class ConcreteVisitor1 : Visitor\r\n    {\r\n        public override void VisitConcreteElementA(\r\n          ConcreteElementA concreteElementA)\r\n        {\r\n            Console.WriteLine(\"{0} 被 {1}访问\",\r\n              concreteElementA.GetType().Name, this.GetType().Name);\r\n        }\r\n\r\n        public override void VisitConcreteElementB(\r\n          ConcreteElementB concreteElementB)\r\n        {\r\n            Console.WriteLine(\"{0} 被 {1}访问\",\r\n              concreteElementB.GetType().Name, this.GetType().Name);\r\n        }\r\n    }\r\n    class ConcreteVisitor2 : Visitor\r\n    {\r\n        public override void VisitConcreteElementA(\r\n          ConcreteElementA concreteElementA)\r\n        {\r\n            Console.WriteLine(\"{0} 被 {1}访问\",\r\n              concreteElementA.GetType().Name, this.GetType().Name);\r\n        }\r\n\r\n        public override void VisitConcreteElementB(\r\n          ConcreteElementB concreteElementB)\r\n        {\r\n            Console.WriteLine(\"{0} 被 {1}访问\",\r\n              concreteElementB.GetType().Name, this.GetType().Name);\r\n        }\r\n    }\r\n    abstract class Element\r\n    {\r\n        public abstract void Accept(Visitor visitor);\r\n    }\r\n    class ConcreteElementA : Element\r\n    {\r\n        public override void Accept(Visitor visitor)\r\n        {\r\n            visitor.VisitConcreteElementA(this);\r\n        }\r\n\r\n        public void OperationA()\r\n        {\r\n        }\r\n    }\r\n    class ConcreteElementB : Element\r\n    {\r\n        public override void Accept(Visitor visitor)\r\n        {\r\n            visitor.VisitConcreteElementB(this);\r\n        }\r\n\r\n        public void OperationB()\r\n        {\r\n        }\r\n    }\r\n    class ObjectStructure\r\n    {\r\n        private List<Element> _elements = new List<Element>();\r\n\r\n        public void Attach(Element element)\r\n        {\r\n            _elements.Add(element);\r\n        }\r\n\r\n        public void Detach(Element element)\r\n        {\r\n            _elements.Remove(element);\r\n        }\r\n\r\n        public void Accept(Visitor visitor)\r\n        {\r\n            foreach (Element element in _elements)\r\n            {\r\n                element.Accept(visitor);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\nConcreteElementA 被 ConcreteVisitor1访问\r\nConcreteElementB 被 ConcreteVisitor1访问\r\nConcreteElementA 被 ConcreteVisitor2访问\r\nConcreteElementB 被 ConcreteVisitor2访问					\r\n					</pre>');
INSERT INTO `designpatterns` VALUES ('24', '解释器模式', '解释器模式（Interpreter Pattern）给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。', 'images/interpreter.gif', '<p>①可扩展性比较好，灵活。</p>\r\n					<p>②增加了新的解释表达式的方式。</p>\r\n					<p>③易于实现简单文法。</p>', '<p>①可利用场景比较少。</p>\r\n					<p>②对于复杂的文法比较难维护。</p>\r\n					<p>③解释器模式会引起类膨胀。</p>\r\n					<p>④解释器模式采用递归调用方法。</p>', '<p>①可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</p>\r\n					<p>②一些重复出现的问题可以用一种简单的语言来进行表达。</p>\r\n					<p>③一个简单语法需要解释的场景。</p>', '<p>分离实现，解释执行。</p>', '<pre>\r\nusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace Interpreter\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Context context = new Context(); \r\n            ArrayList list = new ArrayList();\r\n\r\n            list.Add(new TerminalExpression());\r\n            list.Add(new NonterminalExpression());\r\n            list.Add(new TerminalExpression());\r\n            list.Add(new TerminalExpression());\r\n\r\n            foreach (AbstractExpression exp in list)\r\n            {\r\n                exp.Interpret(context);\r\n            }\r\n            Console.Read();\r\n        }\r\n    }\r\n    class Context\r\n    {\r\n    }\r\n    abstract class AbstractExpression\r\n    {\r\n        public abstract void Interpret(Context context);\r\n    }\r\n    class TerminalExpression : AbstractExpression\r\n    {\r\n        public override void Interpret(Context context)\r\n        {\r\n            Console.WriteLine(\"终端解释器\");\r\n        }\r\n    }\r\n    class NonterminalExpression : AbstractExpression\r\n    {\r\n        public override void Interpret(Context context)\r\n        {\r\n            Console.WriteLine(\"非终端解释器\");\r\n        }\r\n    }\r\n}				\r\n				</pre>\r\n					<p>输出结果：</p>\r\n					<pre>\r\n终端解释器\r\n非终端解释器\r\n终端解释器\r\n终端解释器					\r\n					</pre>');
